<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="subseccion.css" type="text/css">
</head>
<body>
    <a href="../index.html" class="volver">Volver a Apuntes Platzi</a>
    <section>
        <h2>GIT Y GITHUB</h2>

    <article>
      <h3>GIT</h3>
      <p>Git es un sistema de control de versiones que originalmente fue diseñado para operar en un entorno Linux. Actualmente, es multiplataforma, es decir, es compatible con Linux, MacOS y Windows. En la máquina local se encuentra Git, se utiliza bajo la terminal o línea de comandos y tiene comandos como merge, pull, add, commit y rebase, entre otros.</p>
      <p>Caracteristicas de Git:</p>
      <ul>
        <li>Almacena la información como un conjunto de archivos.</li>
        <li>No existen cambios, corrupción en archivos o cualquier alteración sin que Git lo sepa. También lleva un registro de los cambios que otras personas realicen a los archivos.</li>
        <li>Casi todo en git es local. Es difícil que se necesiten recursos o información externos, basta con los recursos locales con los que cuenta.</li>
        <li>Git cuenta con 3 estados en los que podemos localizar nuestros archivos: Staged, Modified y Commietd.</li>
        <li>Permite contar con un historial, regresar a una versión anterior y agregar funcionalidades.</li>
      </ul>
      <p>Con Git se obtiene una mayor eficiencia usando archivos de texto plano, ya que con archivos binarios no puede guardar solo los cambios, sino que debe volver a grabar el archivo completo ante cada modificación, por mínima que sea, lo que hace que incremente demasiado el tamaño del repositorio. Los archivos binarios deben guardarse en un CDN.</p>
    </article>
  
    <article>
      <h3>Github</h3>
      <p>Github es un servicio de alojamiento que ofrece a los desarrolladores, repositorios de software, usando el sistema de control de versiones, Git.</p>
      <p>Características de Github:</p>
      <ul>
        <li>GitHub permite alojar proyectos en repositorios de forma gratuita y pública, pero tiene una forma de pago para privados.</li>
        <li>Puedes compartir fácilmente tus proyectos.</li>
        <li>Permite colaborar para mejorar los proyectos de otros y a otros mejorar o aportar a los tuyos.</li>
        <li>Ayuda a reducir significativamente los errores humanos, a tener un mejor mantenimiento de distintos entornos y a detectar fallos de una forma más rápida y eficiente.</li>
        <li>Es la opción perfecta para poder trabajar en equipo en un mismo proyecto.</li>
        <li>Ofrece todas las ventajas del sistema de control de versiones Git, pero también tiene otras herramientas que ayudan a tener un mejor control de los proyectos.</li>
      </ul>
      <img src="Imagenes Git y Github/gt y github.PNG" alt="Diferencia entre git y github y como se complementan">
    </article>
  
    <article>
      <h3>Comandos básicos en la terminal</h3>
      <ul>
        <li><b>pwd</b> Nos muestra la ruta de carpetas en la que te encuentras ahora mismo.</li>
        <li><b>mkdir</b>  Nos permite crear carpetas (por ejemplo, mkdir Carpeta-Importante).</li>
        <li><b>touch</b> Nos permite crear archivos (por ejemplo, touch archivo.txt).</li>
        <li><b>rm</b>  Nos permite borrar un archivo o carpeta (por ejemplo, rm archivo.txt). Mucho cuidado con este comando, puedes borrar todo tu disco duro.</li>
        <li><b>cat</b> Ver el contenido de un archivo (por ejemplo, cat nombre-archivo.txt).</li>
        </li>
        <li><b>ls</b> Ver el contenido de un archivo (por ejemplo, cat nombre-archivo.txt).Nos permite cambiar ver los archivos de la carpeta donde estamos ahora mismo. Podemos usar uno o más argumentos para ver más información sobre estos archivos (los argumentos pueden ser -- + el nombre del argumento o - + una sola letra o shortcut por cada argumento):
          <ul id="subviñetas">
            <li><b>ls -a</b>: Mostrar todos los archivos, incluso los ocultos.</li>
            <li><b>ls -l</b>: Ver todos los archivos como una lista.</li>
          </ul></li>
        <li><b>cd</b> Nos permite navegar entre carpetas.
        <ul id="subviñetas">
          <li><b>cd /</b>: Ir a la ruta principal.</li>
          <li><b>cd o cd ~</b>: Ir a la ruta de tu usuario.</li>
          <li><b>cd carpeta/subcarpeta</b>: Navegar a una ruta dentro de la carpeta donde estamos ahora mismo.</li>
          <li><b>cd .. (cd + dos puntos)</b>: Regresar una carpeta hacia atras.</li>
          <li><b>cd . (cd + un punto)</b>: Para referirte al directorio en el que te encuentras ahora mismo.</li>
        </ul>
        </li>
        <li><b>history</b> Ver los últimos comandos que ejecutamos y un número especial con el que podemos repetir su ejecución.</li>
        <li><b>! + número</b> Ejecutar algún comando con el número que nos muestra el comando history (por ejemplo, !72).</li>
        <li><b>clear</b> Para limpiar la terminal. También podemos usar los atajos de teclado Ctrl + L o Command + L.</li>
        <li>Recuerda que podemos descubrir todos los argumentos de un comando con el argumento <b>--help</b> (por ejemplo, cat --help).</li>
      </ul>
    </article>

    <article>
      <h3>Comandos para iniciar repositorio con Git</h3>
      <p>Le indicaremos a Git que queremos crear un nuevo repositorio para utilizar su sistema de control de versiones. Solo debemos posicionarnos en la carpeta raíz de nuestro proyecto y ejecutar:</p>
      <ul>
        <li><b>git init</b>: Lo usamos para determinar la carpeta en la que vamos a trabajar.</li>
        <li><b>git status</b>: Lo usamos para saber si tenemos un archivo añadido o borrado en nuestro proyecto, para saber en la rama en la que estamos y si tenemos commits.</li>
        <li><b>git add</b>: Es para añadir un archivo a nuestra rama seguidamente ponemos entre comillas el nombre de nuestro archivo o poner un punto para añadir todos los archios de nuestra carpeta.</li>
        <li><b>git rm</b>:  Lo usamos para borrar un archivo que hayamos añadido, para eliminarlo por completo de nuestra rama usamosgit rm --cached.</li>
        <li><b>git commit</b>: Se usa para añadir un commit a nuestra rama, también podemos ponerle un -m seguidamente ponemos entre comillas nuestro ensaje.</li>
        <li><b>git config</b>: Muestra configuraciones de git también podemos usar <b>-list</b> para mostrar la configuración por defecto de nuestro git y si añadimos <b>--show-origin</b> nos muestra las configuraciones guardadas y su ubicación.</li>
        <li><b>git config --global user.name</b>: Cambia de manera global el nombre del usuario, seguidamente ponemos entre comillas nuestro nombre.</li>
        <li><b>git config --global user.email</b>: Cambia de manera global el email del usuario, seguidamente ponemos entre comillas nuestro nombre.</li>
        <li><b>git log</b>: Se usa para ver la historia de nuestros archivos, los commits, el usuario que lo cambió, cuando se realizaron los cambios etc. seguidamente ponemos el nombre de nuestro archivo.</li>
      </ul>
    </article>

    <article>
      <h3>Comandos para analizar cambios en GIT</h3>
      <p>El comando <b>git show</b> nos muestra los cambios que han existido sobre un archivo y es muy útil para detectar cuándo se produjeron ciertos cambios, qué se rompió y cómo lo podemos solucionar. Pero podemos ser más detallados.</p>
      <p>Si queremos ver la diferencia entre una versión y otra, no necesariamente todos los cambios desde la creación del archivo, podemos usar el comando <b>git diff</b> commitA commitB</p>
      <img src="Imagenes Git y Github/cambios en git.png">
    </article>

    <article>
      <h3>Qué es un staging</h3>
      <p><b>git init</b> es el comando que activa git en nuestro proyecto creando un espacio en memoria RAM llamado staging y ua carpeta .git.</p>
      <img src="Imagenes Git y Github/stagging.png">
      <p>Staging es el lugar donde se guardan temporalmente los cambios, para luego ser guardados definitivamente en el repositorio.
      </p>
      <p><b>.git</b> es donde se guarda el historial de cambios de nuestros archivos.</p>
      <p>En git existen cuatro estados para los archivos:</p>
      <ul>
        <li><b>Untracked</b>: el archivo no vive en git, solo en el disco duro.</li>
        <li><b>Unstaged</b>: Son archivos que git tiene registro de sus cambios pero están desactualizados.</li>
        <li><b>Staged</b>: Archivos que han sido enviados a staging con git add.</li>
        <li><b>Tracked</b>: Los archivos viven dentro del repositorio, están actualizados y no tienen cambios pendientes.</li>
      </ul>
      <p>Staging entonces es un lugar donde con git add se mandan nuestros archivos para ser guardados <b>temporalmente</b>. Repositorio es el lugar donde se guardan todos los registros de los cambios realizados a los archivos.</p>
      <p>Algunos comandos utiles para el staging:</p>
      <ul>
        <li><b>git status</b>: nos permite ver el estado de todos nuestros archivos y carpetas.</li>
        <li><b>git add</b>: nos ayuda a mover archivos del untracked o unstaged al estado de staged.</li>
        <li><b>git commit</b>: nos ayuda a mover archivos de unstaged a staged.</li>
        <li><b>git reset HEAD</b>: nos ayuda a sacar archivos del estado staged para devolverlos a su estado anterior.</li>
      </ul>
    </article>

    <article>
      <h3>Branch y Merge</h3>
      <p>Una rama o branch es una versión del código del proyecto sobre el que estás trabajando. Estas ramas ayudan a mantener el orden en el control de versiones y manipular el código de forma segura. En otras palabras, un branch o rama en Git es una rama que proviene de otra. Imagina un árbol, que tiene una rama gruesa, y otra más fina, en la rama más gruesa tenemos los commits principales y en la rama fina tenemos otros commits que pueden ser de hotfix, devlopment entre otros.</p>
      <img src="Imagenes Git y Github/branch y merge.png">
      <p>Ramas en git o branches:</p>
      <ul>
        <li><b>Rama main(Main antes conocida como Master)</b>: Por defecto, el proyecto se crea en una rama llamada Main. Cada vez que añades código y guardas los cambios, estás haciendo un commit, que es añadir el nuevo código a una rama. Esto genera nuevas versiones de esta rama o branch, hasta llegar a la versión actual de la rama Main.</li>
        <li><b>Rama development</b>: Cuando decides hacer experimentos, puedes generar ramas experimentales (usualmente llamadas development), que están basadas en alguna rama main, pero sobre las cuales puedes hacer cambios a tu gusto sin necesidad de afectar directamente al código principal.</li>
        <li><b>Rama hotfix</b>: En otros casos, si encuentras un bug o error de código en la rama Main (que afecta al proyecto en producción), tendrás que crear una nueva rama (que usualmente se llaman bug fixing o hot fix) para hacer los arreglos necesarios. Cuando los cambios estén listos, los tendrás que fusionar con la rama Main para que los cambios sean aplicados. Para esto, se usa un comando llamado Merge, que mezcla los cambios de la rama que originaste a la rama Main.</li>
      </ul>
      <p><b>Como crear una rama en git:</b></p>
      <p>El comando git branch permite crear una rama nueva. Si quieres empezar a trabajar en una nueva función, puedes crear una rama nueva a partir de la rama master con git branch new_branch. Una vez creada, puedes usar git checkout new_branch para cambiar a esa rama.</p>
      <ul>Comandos de ramas:
        <li><b>git branch -nombre de la rama-:</b> Con este comando se genera una nueva rama.</li>
        <li><b>git checkout -nombre de la rama-:</b> Con este comando puedes saltar de una rama a otra.</li>
        <li><b>git checkout -b rama:</b> Genera una rama y nos mueve a ella automáticamente, Es decir, es la combinación de git branch y git checkout al mismo tiempo.</li>
        <li><b>git reset id-commit:</b> Nos lleva a cualquier commit no importa la rama, ya que identificamos el id del tag., eliminando el historial de los commit posteriores al tag seleccionado.</li>
        <li><b>git checkout rama-o-id-commit:</b> Nos lleva a cualquier commit sin borrar los commit posteriores al tag seleccionado.</li>
      </ul>
      <p><b>Cómo hacer un merge:</b></p>
      <p>Producir una nueva rama se conoce como Checkout. Unir dos ramas lo conocemos como Merge.
      Cuando haces merge de estas ramas con el código principal, su código se fusiona originando una nueva versión de la rama master (o main) que ya tiene todos los cambios que aplicaste en tus experimentos o arreglos de errores.</p>
      <p>Un ejemplo de git merge:</p>
      <ul>
        <li>Git checkout main</li>
        <li>git merge cabecera</li>
        <li>Si nos hemos equivocado y queremos cancelar un merge debemos poner: <b>git merge --abort</b></li>
      </ul>
      <img src="Imagenes Git y Github/merge.png">
    </article>

    <article>
      <h3>Volver en el tiempo en nuestro repositorio utilizando reset y checkout
      </h3>
      <p>El comando <b>git checkout + ID del commit</b> nos permite viajar en el tiempo. Podemos volver a cualquier versión anterior de un archivo específico o incluso del proyecto entero. Esta también es la forma de crear ramas y movernos entre ellas.
      También hay una forma de hacerlo un poco más “ruda”: usando el comando <b>git reset.</b> En este caso, no solo “volvemos en el tiempo”, sino que borramos los cambios que hicimos después de este commit.
      </p>
      <p>Hay dos formas de usar git reset: con el argumento <b>--hard,</b> borrando toda la información que tengamos en el área de staging (y perdiendo todo para siempre). O, un poco más seguro, con el argumento <b>--soft,</b> que mantiene allí los archivos del área de staging para que podamos aplicar nuestros últimos cambios pero desde un commit anterior.</p>
      <p>Como usar git reset:</p>
      <ul>
        <li><b>git reset --soft:</b> elimina los cambios hasta el staging área.</li>
        <li><b>git reset --mixed:</b> elimina los cambios hasta el working área.</li>
        <li><b>git reset --hard:</b> borra todo incluyendo el staging. </li>
        <li><b>git reset HEAD:</b> Este es el comando para sacar archivos del área de staging. No para borrarlos ni nada de eso, solo para que los últimos cambios de estos archivos no se envíen al último commit, a menos que cambiemos de opinión y los incluyamos de nuevo en staging con git add, por supuesto.</li>
      </ul>
      <img src="Imagenes Git y Github/git rm y reset.png">
    </article>

    <article>
      <h3>Servidor y repositorio remoto</h3>
      <p>Cuando empiezas a trabajar en un entorno local, el proyecto vive únicamente en tu computadora. Esto significa que no hay forma de que otros miembros del equipo trabajen en él.
      Para solucionar esto, utilizamos los servidores remotos: un nuevo estado que deben seguir nuestros archivos para conectarse y trabajar con equipos de cualquier parte del mundo.
      Estos servidores remotos pueden estar alojados en GitHub, GitLab, BitBucket, entre otros. Lo que van a hacer es guardar el mismo repositorio que tienes en tu computadora y darnos una URL con la que todos podremos acceder a los archivos del proyecto. Así, el equipo podrá descargarlos, hacer cambios y volverlos a enviar al servidor remoto para que otras personas vean los cambios, comparen sus versiones y creen nuevas propuestas para el proyecto.</p>
      <p>Comandos para trabajo remoto con git:</p>
      <ul>
        <li><b>git clone url_del_servidor_remoto:</b>Nos permite descargar los archivos de la última versión de la rama principal y todo el historial de cambios en la carpeta .git.</li> 
        <li><b>git push:</b> Luego de hacer git add y git commit debemos ejecutar este comando para mandar los cambios al servidor remoto.</li>
        <li><b>git merge:</b> También usamos el comando git merge con servidores remotos. Lo necesitamos para combinar los últimos cambios del servidor remoto y nuestro directorio de trabajo.</li>
        <li><b>git pull:</b> Básicamente, git fetch y git merge al mismo tiempo.</li>
      </ul>
      <img src="ruta/a/la/foto1.jpg" alt="Descripción de la foto 1">
    </article>

    <article>
      <h3>Github y HTTP</h3>
      <p>GitHub es una plataforma que nos permite guardar repositorios de Git que podemos usar como servidores remotos y ejecutar algunos comandos de forma visual e interactiva (sin necesidad de la consola de comandos). Luego de crear nuestra cuenta, podemos crear o importar repositorios, crear organizaciones y proyectos de trabajo, descubrir repositorios de otras personas, contribuir a esos proyectos, dar estrellas y muchas otras cosas.
      <p>El README.md es el archivo que veremos por defecto al entrar a un repositorio. Es una muy buena práctica configurarlo para describir el proyecto, los requerimientos y las instrucciones que debemos seguir para contribuir correctamente.</p>
      <p>Para clonar un repositorio desde GitHub (o cualquier otro servidor remoto) debemos copiar la URL (por ahora, usando HTTPS) y ejecutar el comando git clone + la URL que acabamos de copiar. Esto descargará la versión de nuestro proyecto que se encuentra en GitHub.</p>
      <img src="Imagenes Git y Github/subir proyecto a git.png">
    </article>

    <article>
      <h3>Llaves públicas y privadas</h3>
      <p>Para evitar el hackeo se inventaron las llaves publicas y privadas que sirven para enviar / recibir cierto contenido privado (así se manejan por ejemplo los bancos)</p>
      <ul>
        <li>La llave publica y privada esta relacionada matematicamente.</li>
        <li>La llave publica cifra el contenido del mensaje.</li>
        <li>Cada persona en esa comunicacion tiene tanto llave privada como publica.</li>
        <li>Si yo quiero mandarle a la otra persona el mensaje debo cifrarlo con su llave publica ya que el lo terminara abriendo con su llave privada.</li>
        <li>En caso contrario el debe enviarme el mensaje con mi llave publica así yo puedo abrirlo con mi llave privada.</li>
        <li>Si un hacker o alguien captura la llave publica da absolutamente igual ya que el mensaje se desoculta solo con la llave privada correspondiente. (Las llaves con un algoritmo y es conocido como cifrado asimétrico de un solo camino)</li>
        <li>En caso de github tendré mi llave publica y mi llave privada y solo le daré a github mi llave publica, para que el use mi llave publica de mi llave privada y podamos intercambiar cosas.</li>
        <li>Nos conectaremos por un protocolo que no es https, será SSH.</li>
        <li>Github tiene llave publica tambien y será de mi conocimiento. También tiene su llave privada y gracias a eso podremos hacer intercambios.</li>
      </ul>
      <img src="Imagenes Git y Github/llave ssh.png">
    </article>

    <article>
      <h3>Subir un commit a github por primera vez con SSH</h3>
      <ul>
        <li>git remote -v (para ver cual es la url en fetch y push, usualmente son las mismas).</li>
        <li>ir a mi repositorio y donde dice "code" copiar codigo SSH.</li>
        <li>poner git remote add origin y el url.</li>
        <li>(esto es para cambiar si empece en https y quiero usar ssh) =>poner git remote set-url origin (y el codigo que copie en el paso anterior, origin cambia fetch y push).</li>
        <li>poner git remote -v (para verificar que cambio).</li>
        <li>poner git pull (me va a preguntar si es seguro y blabla y digo yes).</li>
      </ul>
      <p>Para subir un commit:</p>
      <ul>
        <li>git status para ver que modifique.</li>
        <li>git diff (si quiero ver la diferencia con versiones anteriores).</li>
        <li>git commit -am "mensaje del cambio que hice como agregue esto blabla"</li>
        <li>git pull origin main (acá va la rama y te trae lo que está en el repositorio).</li>
        <li>git push origin main (acá va la rama).</li>
      <p>Ejemplo de como subí mi página Mokepon a Github:</p>
      </ul>
      <img src="Imagenes Git y Github/mokepon1.png">
      <img src="Imagenes Git y Github/mokepon2.png">
      <img src="Imagenes Git y Github/mokepon3.png">
    </article>

    <article>
      <h3>Cambiar de master a main</h3>
      <p>EL GIT PULL ORIGIN MASTER (MAIN ACTUALMENTE) => pasas de master a main en la pc con git branch -m master main
      <ul>
        <li>el git pull origin main es antes de hacer algun cambio para traer el github del internet a la terminal.</li>
        <li>git push origin es ya pa enviar los cambios al internet (github).</li>
      </ul>
      </p>
    </article>

    <article>
      <h3>Para fusionar ramas</h3>
      <ul>
        <li>Vamos a la rama maestra, en mi caso git checkout main.</li>
        <li>git merge (+ rama que queramos) en mi caso header.</li>
        <li>Le agrego algún mensaje con shift + i (insert) y apreto esc tab zz, para salir.</li>
        <li>git pull origin main, te traes lo que haya en internet.</li>
        <li>git push origin main, para subir los cambios al internet.</li>
      </ul>
    </article>

    <article>
      <h3>Pull request</h3>
      <p>Si te gusta el proyecto podes darle watch para que te lleguen notificaciones y darle estrellita para que te den avisos cuando haya cambios en el proyecto.</p>
      <p>Para hacer una contribucióna un proyecto de Github hay que seguir los siguientes pasos:</p>
      <ul>
        <li>Darle al botón de Fork en Github.</li>
        <img src="Imagenes Git y Github/fork.png">
        <li>Clonar con https o SSH git clone + link correspondiente, puedo agregar ls, status, y demás para ver.</li>
        <li>Procedo a hacer los cambios, git commit -am "mensaje del cambio" seguido de git status, 
        seguido de git pull origin master/main y luego git push origin/master (si, solo tengo main al clonar).</li>
        <li>Hacer un pull request con mis cambios en alguna de las ramas del proyecto original y esperar.
          <img src="Imagenes Git y Github/pull request 2.png">
        </li>
        <li>Una vez aprueben o rechacen mis cambios seré notificado en la cuenta de github, se aprueba con merge pull request si sos el dueño del proyecto.</li>
      </ul>
      <p>Pero también pasa algo muy interesante y es que cuando yo he hecho un fork, el proyecto original sigue avanzando y el mio se va quedando atras, así que para traer los cambios del proyecto original eso se hace de la siguiente manera:</p>
      <ul>
        <li>Crear una nueva fuente para hacer pull desde el repositorio forkeado.</li>
        <li>Ponmemos git remote -v y vemos nuestro git de usuario y ese no es...</li>
        <li>git remote add upstream [original_repository_url] (en clonar con https o ssh)
          <p>Nota: la palabra upstream es opcional pero es lo que normalmente se usa en la industria.</p>
        </li>
        <li>Verificamos que hay una nueva fuente de datos con git remote -v.</li>
        <li>Hacer pull de upstream/master => git pull upstream master.</li>
        <li>Hacer un commit para fusionar los cambios que hemos traído => git commit -am “Fusion”.</li>
        <li>Hacer un push para mandar los cambios a nuestro repositorio original => git push origin master</li>
      </ul>
      <img src="Imagenes Git y Github/pull request.png">
    </article>

    <article>
      <h3>.GITIGNORE</h3>
      <p>Lista de cosas buenas a ignorar usualmente:
        <img src="Imagenes Git y Github/lista de buenos gitignore.png">
      </p>
      <ul>
        <li>Creamos con control + n, en code un archivo.</li>
        <li>lo guardamos como .gitignore.</li>
        <li>le escirbimos adentro en el code, qué queremos ignorar.
          <p>acá por ejemplo le dije que queria ignorar todos (*) con ese simbolo, los archivos jpg
            <img src="Imagenes Git y Github/gitignore.png">
          </p>
        </li>
      </ul>
    </article>

    <article>
      <h3>README.md y markdown</h3>
      <p>README.md es el lugar dónde se explica de qué trata el proyecto, cómo utilizarlo y demás información que se considere que se deba conocer antes de utilizar un proyecto.
      <p>Los archivos README son escritos en un lenguaje llamado markdown, por eso la extensión .md, mismo que es un estándar de escritura en diversos sitios (como platzi, como wikipedia y obvio GitHub), ver reglas de markdown.</p>
      <p>Los README.md pueden estar en todas las carpetas, pero el más importante es el que se encuentra en la raíz y ayudan a que los colaboradores sepan información importante del proyecto, módulo o sección, puedes crear cualquier cualquier archivo con la extensión .md pero sólo losn README.md los mostrará por defecto GitHub.</p>
      <p>Para editar el readme y que quede bonito:
        <a href = https://pandao.github.io/editor.md/en.html></a>
      </p>
      <p>Copiamos lo que sea que hagamos ahi primero borrando todo el texto que aparece y lo pegamos en el code. 
        <img src="Imagenes Git y Github/editor.png">
      </p>
    </article>

    <article>
      <h3>GITHUBE PAGES GRATIS PARA TENER TU REPOSITORIO</h3>
      <ul>
        <li>Abrimos <a href = https://pages.github.com></a></li>
        <li>Create new repository</li>
      </ul>
      <img src="ruta/a/la/foto1.jpg" alt="Descripción de la foto 1">
    </article>

    <article>
      <h3>GIT REBASE PARA REORGANIZAR EL TRABAJO</h3>
      <ul>
        <li>Tengo mi rama master.</li>
        <li>Tengo otra rama llamada bugfix.</li>
        <li>Quiero hacer un merge del bugfix a master.</li>
        <li>Qué hago si quiero, en vez de merge, borrar la rama bugfix pero que antes se integre los cambios al master, asi como si nunca hubiera pasado nada?<p>Se debe hacer un rebase para lograr eso.</p></li>
      </ul>
      <p>En vez de esto: <img src="Imagenes Git y Github/mergerebase.png"></p>
      <p>Es esto:
        <img src="Imagenes Git y Github/rebase.png">
        Es mala práctica si la envias a un repositorio en donde hay otros trabajando.
      </p>
      <p>Pasos para hacer rebase:</p>
      <ul>
        <li>Estando en la rama bugfix o como sea, le doy git rebase main.</li>
        <li>git checkout main para volver al main.</li>
        <li>git commit -am "mensaje"</li>
        <li>git checkout bugfix</li>
        <li>git rebase main en la rama main</li>
      </ul>
      <p>El hacer rebase a la rama que quiero desaparecer y luego rebase a la rama main(que son los pasos de arriba) hace que bugfix sea head, arranco un commit adelante, y por eso rebase es mala practica cambia la historia de donde se hace el branch.</p>
      <p>Luego de los pasos anteriores:</p>
      <ul>
        <li>git rebase bugfix en main</li>
        <li>git pull origin main</li>
        <li>git push origin main</li>
      </ul>
      <p>Con esto a nivel de historia la rama bugfix nunca existio, rebase es cambio silencioso basicamente, con esto no se sabe quien hizo que y si la rama main avanzo mucho en el trayecto del rebase porque otro andaba trabajando puede traer muchos conflictos.</p>
    </article>

    <article>
      <h3>STASHED</h3>
      <p>El stashed nos permite cambiar de ramas, hacer cambios, trabajar en otras cosas y, más adelante, retomar el trabajo con los archivos que teníamos en Staging pero que podemos recuperar ya que los guardamos en el Stash.
      <p>Esto sirve para cuando un cambio no es lo suficientemente bueno para hacer un commit, dejarlo ahí sin perder el trabajo.</p>
      <ul>
        <li>git stash (guarda cambios en lugar temporal).</li>
        <li>git stash list (para ver que guarde).</li>
        <li>Ya puedo cambiar de rama gracias a esto, antes no me dejaba porque debia hacer commit pa guardar el cambio.</li>
        <li>vuelvo a la rama donde deje el stash
          <img src="Imagenes Git y Github/stash.png"> => esto si hay muchas cosas en stash mejor guardarlas con un mensaje para saber qué cosa es que.
        </li>
        <li>git stash pop (para que aparezca lo que estabas haciendo una vez vuelves a la rama donde hiciste stash) para poner el stash en una rama nueva.</li>
        <li>git stash branch "nombre de la rama"</li>
        <li>Si quiero ya que sea oficial el cambio le hago git commit -am "m sj que ponga"</li>
        <li>git stash drop, sirve si no quiero guardar un stash porque no me gustó o arruine algo, se borra.</li>
      </ul>
    </article>

    <article>
      <h3>Git clean</h3>
      <ul>
        <li>git clean --dry-run (simula lo que queres borrar sin borrarlo), ejemplo añadiste archivos por accidente al proyecto.</li>
        <li>git clean -f (para si borrarlo ahora si).</li>
        <li>git status para ver si se borro todo.</li>
        <li>Si no se borra algo puede que sea porque este en .gitignore (en este ejmplo copie imagenes y justo jpg estaba en gitignore y no se borro).</li>
        <li>Lo que no se borre con ese comando, ya borralo manual.</li>
      </ul>
    </article>

    <article>
      <h3>Cherry Pick</h3>
      <p>Este comando permite coger uno o varios commits de otra rama sin tener que hacer un merge completo.</p>
      <ul> 
        <li>git log --oneline para ver todos los cambios en 1 linea , en superlog salen con dibujitos. Asi podre ver los commits.</li>
        <li>si quiero un commit en una rama especifica entonces, me voy a la rama que quiera el commit y pongo: <b>git cherry -pick</b></li>
        <li>git log --oneline en la rama que sea donde este el commit para buscarlo.</li>
        <li>Copio el commit que quiero.</li>
        <li>Vuelvo a la rama donde quiero colocarlo.</li>
        <li>git cherry pick + codigo del commit que copié.</li>
        <li>git pull origin (rama donde hice todo).</li>
        <li>git push origin (rama donde hice todo).</li>
      </ul>
    </article>

    <article>
      <h3>GIT RESET Y REFLOG</h3>
      <p>Git guarda todos los cambios aunque decidas borrarlos, al borrar un cambio lo que estás haciendo sólo es actualizar la punta del branch, para gestionar éstas puntas existe un mecanismo llamado registros de referencia o reflogs. EJEMPLO: borre un branch importante por error con git branch -d cabecera  DDD:!!!</p>
      <ul>
        <li>git log para ver que pasó.</li>
        <li>git reflog para ver TODO lo que pasó.</li>
        <li>copias el HEAD desde el cual todo estaba bien como por ejemplo aqui: <img src="Imagenes Git y Github/reset1.png"></li>
        <li> git reset --SOFT O --HARD. Soft mantiene lo que esté en stagging en staggin o sea lo que está pendiente por hacer commit. Hard resea todo.</li>
        <li> en este caso ponemos git reset (y lo que copiamos) le quita el stage a los cambios pero si queremos los archivos que borramos tenemos que...</li>
        <li>git reflog y copiar: <img src="Imagenes Git y Github/reset2.png"></li>
        <li> git reset --HARD + lo copiado que es el hash.
          LISTO TODO VUELVE A LA NORMALIDAD!!!</li>
      </ul>
    </article>

    <article>
      <h3>Amend</h3>
      <p>Digamos que haces un cambio al archivo a.txt y haces un commit.Luego subes ese commit al repositorio haciendo push... Pero se te olvido agregar cambios a ese commit y quieres enmendarlo.
      <p>Haces un git --amend y en la historia de tu repositorio local, pareciera que no ha pasado nada: enmendaste tu commit. Luego hacer git pull y push.</p>
      <p>El git amend basicamente pega los cambios al commit anterior en el que te olvidaste algo.</p>
    </article>

    <article>
      <h3>GREP Y LOG</h3>
      <p>Grep sirve para buscar en cuantos lugares use una palabra especifica</p>
      <ul>
        <li>git grep + palabra a buscar.</li>
        <li>git grep -n + palabra a buscar para ver las lineas en donde usé</li>
        <li>git crep -c + palabra para ver cuantas veces use esa palabra.</li>
      </ul>
      <p>Si lo que quiero buscar no está en el codigo pero si en la historia de los commits:</p>
      <ul><li>git log -S "palabra a buscar entre comillas".</li></ul>
      <p>Basicamente grep es para archivos, log para commits.</p>
    </article>

    <article>
      <h3>COMANDOS INTERNOS PARA CUANDO TRABAJAS EN GRUPO</h3>
      <ul>
        <li><b>git shorlog:</b> Ver cuantos commits a hecho los miembros del equipo, como un log por persona.</li>
        <li><b>git shortlog -sn:</b> Las personas que han hecho ciertos commits.</li>
        <li><b>git shortlog -sn --all:</b> Todos los commits (también los borrados).</li>
        <li><b>git shortlog -sn --all --no-merges:</b> Muestra las estadisticas de los comits del repositorio donde estoy,</li>
        <li>Para crear un comando con lo anterior: git config --global alias.stats “shortlog -sn --all --no-merges”: configura el comando “shortlog -sn --all --no-merges” en un Alias en las configuraciones globales de git del pc, se activa con git stats (commits sin merge de cada uno de los miembros del repositorio).</li>
        <li><b>git blame -c + archivo que quiera ver:</b> Muestra quien ha hecho cambios en dicho archivo identado.</li>
        <li><b>git blame --help:</b> Muestra en el navegador el uso del comando, en este caso blame.</li>
        <li><b>git blame + archivo que quiera ver -L 35, 60 -c:</b> Muestra quien escribio el codigo con informacion de la linea 35 a la 60, EJ: git blame css/estilos.css -L 35, 60 -c (se puede poner sin -c pero el -c hace que sea mas especifico)</li>
        <li><b>git branch -r:</b>  Muestra las Ramas remotas de GitHub, es decir las que están en tu servidor en github.</li>
        <li><b>git branch -a:</b> Muestra todas las Ramas del repositorio y remotas de GitHub.</li>
      </ul>
      <img src="Imagenes Git y Github/subir proyecto a git.png">
    </article>
  </section>
</body>
</html>